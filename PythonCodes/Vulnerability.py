"""
Stores information about vulnerability, including its Rule-id as id, instanceid,
kingdom, category, FuntionDeclarationSourceLocation: path as filename,
Function name as function, replacementDefinitions as a dictionary each key
corresponding to value, traces as Trace object list, externalEntries as
ExternalEntry list
"""
import re
class Vulnerability:

    def __init__(self, id, instanceid, kingdom, category, primaryFunction, filename, severity, function, line, replacementDefinitions):
        self.kingdom = kingdom
        self.id = id
        self.instanceid = instanceid
        self.filename = filename
        self.description = None
        self.line = line
        self.function = function
        self.severity = severity
        self.category = category
        self.replacementDefinitions = replacementDefinitions
        self.primaryFunction = primaryFunction
        self.traces = []
        self.externalEntries = []
        self.fileNum = 0
        self.tracesString = ""

    def getRuleId(self):
        return self.id

    def getDescription(self):
        return self.description

    def getExternalEntries(self):
        return self.externalEntries

    def getFileNum(self):
        return self.fileNum

    def getInstanceid(self):
        return self.instanceid

    def getReplacementDefinitions(self):
        return self.replacementDefinitions

    def getKingdom(self):
        return self.kingdom

    def getTraces(self):
        return self.traces

    def getCategory(self):
        return self.category

    def getFilename(self):
        return self.filename

    def getLine(self):
        return self.line

    def getPrimaryFunction(self):
        return self.primaryFunction

    def getFunction(self):
        return self.function

    def getSeverity(self):
        return self.severity

    def addExternalEntry(self, tempEntry):
        self.externalEntries.append(tempEntry)

    def __str__(self):
        str = ""
        str += " ID is %s, Kingdom is %s Category is %s, Filename is %s line is %s, function is %s severity is %s \n" % (
        self.id, self.kingdom, self.category, self.filename, self.line, self.function, self.severity)
        str += " Replacement Definitions Dictionary is %s \n" % (self.replacementDefinitions)
        return str

    def dereferenceTraces(self, tracePool):
        tempTraces = self.traces
        for trace in tempTraces:
            self.dereferenceTrace(trace, tracePool)

    def dereferenceTrace(self, trace, tracePool):
        for node in (trace.getTraceNodes()):
            self.dereferenceTraceNode(node, tracePool)

    def dereferenceTraceNode(self, traceNode, tracePool):
        if traceNode.getNodeRef() == "":
            if traceNode.getReason() != None:
                self.dereferenceTrace( traceNode.getReason(), tracePool)
        else:
            for tempPool in tracePool:
                if tempPool.getNodeRef() == traceNode.getNodeRef():
                    traceNode.actionType = tempPool.getActionType()
                    traceNode.actionText = tempPool.getActionText()
                    traceNode.path = tempPool.getPath()
                    traceNode.line = tempPool.getLine()
                    traceNode.lineEnd = tempPool.getLineEnd()
                    traceNode.reason = tempPool.getReason()
                    if tempPool.getReason() != None:
                        self.dereferenceTrace( traceNode.getReason(), tracePool)

    def getTracesString(self):
        tempTraces = self.traces
        str = ""
        for trace in tempTraces:
            str = self.getTraceData(trace, str)
            str += " + "
        return str

    def getTraceData(self, trace, str):
        for node in (trace.getTraceNodes()):
            str = self.getTraceNodeData(node, str)
            str += " & "
        return str

    def getTraceNodeData(self, traceNode, str):
        str += traceNode.getPath()
        str += ":"
        str += traceNode.getLine()
        if( traceNode.getActionText() != ""):
            str += " - "
            k = traceNode.getActionText()
            k = k.replace("\"", "\\")
            str += k
        elif( traceNode.getLabel() != ""):
            str += " - "
            str += traceNode.getLabel()
        if traceNode.getReason() != None:
            str += "& { &"
            str = self.getTraceData(traceNode.getReason(), str)
            str += "} "
        return str

    # Prints every traces of certain vulnerability with the help of printTrace function
    def printTraces(self):
        tempTraces = self.traces
        for trace in tempTraces:
            print("Trace Information: \n")
            self.printTrace(trace)
            print("---------------------------------------------------------------------------------------")

    # Prints every node in single trace using printTraceNode method
    def printTrace(self, trace):
        for node in (trace.getTraceNodes()):
            self.printTraceNode(node)

    # Recursive function to print every node with their reasons
    def printTraceNode(self, traceNode):
        str = "Action Type: %s \nAction Text %s \nPath: %s \nLine: %s \nLine End: %s \nLabel: %s \nIs Default: %s \n" % (
            traceNode.getActionType(), traceNode.getActionText(), traceNode.getPath(), traceNode.getLine(),
            traceNode.getLineEnd(),
            traceNode.getLabel(), traceNode.getIsDefault())
        print(str)

        # If reason field of the node exists, print it as a trace, using printTrace function
        if (traceNode.getReason() != None):
            print("--Reason--")
            self.printTrace(traceNode.getReason())
            print("\n")
            print("--Reason End--")

    def getDefaultTrace(self):
        tempTrace = self.traces[0]
        for tempNode in tempTrace.getTraceNodes():
            if tempNode.getIsDefault():
                tempArr = tempNode.getPath().split("/")
                primaryLine = tempNode.getLine()
                str = ""
                str += tempArr[len(tempArr) - 1]
                str += ":"
                str += primaryLine
                return str, tempNode.getPath(), primaryLine
        return "undefined"

    def dereferenceDescription(self):
        regex = re.compile(r'Replace key=\"[^"]*\"')
        abstract = self.getDescription().getAbstract()
        keys = re.findall(regex, abstract)
        for i in range(len(keys)):
            tempKey = keys[i].split("\"")
            tempStr = tempKey[1]
            if tempStr in self.replacementDefinitions:
                abstract = abstract.replace(keys[i], self.replacementDefinitions[tempStr], 1)
            else:
                abstract = abstract.replace(keys[i], "", 1)
        self.getDescription().abstract = abstract
        explanation = self.getDescription().getExplanation()
        keys = re.findall(regex, explanation)
        for i in range(len(keys)):
            tempKey = keys[i].split("\"")
            tempStr = tempKey[1]
            if tempStr in self.replacementDefinitions:
                explanation = explanation.replace(keys[i], self.replacementDefinitions[tempStr], 1)
            else:
                explanation = explanation.replace(keys[i], "", 1)
        self.getDescription().explanation = explanation
        recommendations = self.getDescription().getRecommendations()
        keys = re.findall(regex, recommendations)
        for i in range(len(keys)):
            tempKey = keys[i].split("\"")
            tempStr = tempKey[1]
            if tempStr in self.replacementDefinitions:
                recommendations = recommendations.replace(keys[i], self.replacementDefinitions[tempStr], 1)
            else:
                recommendations = recommendations.replace(keys[i], "", 1)
        self.getDescription().recommendations = recommendations